---
title: "Assemblage Dispersion Fields"
author: "Patrick Alexander Walkden"
date: "03/08/2021"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## PREDICTS Assembly

## Assemblage dispersion fields

There are many decisions that need to be made when performing an analysis of trait based community assembly. The functional diversity metric to use, how to randomise the trait and community matrices to produce null models in the absence of a particular process, and, what we are concerned with here, how to define the species pool which species in this null community are drawn. 

Defining the species pool correctly is integral in any analysis of community assembly and it can be thought of as the pool of species that could potentially disperse to and colonise a focal site in the absence of all other assembly processes, be it environmental filtering or biotic interactions such as competition or limiting similarity. The definition of the species pool affects the degree and thus the interpretation of subsequent results. 

There have been a number of ways suggested to define the species pool. Most simply and commonly used is defining the species pool as all the species observed within a study across all sites. This works adequately when researchers have undertaken their studies with the explicit focus on testing community assembly processes and surveyed communities across an suitably broad environmental gradient. However, using data from PREDICTS studies rarely collect data across the entire land-use gradient therefore by using this method our species pool will always be restricted to those species that are able to persist in the land-use gradient surveyed rather than the entire species pool. Additionally, a lot of what is termed as "dark diversity" (rare species) can be missed.

Therefore another method proposed to define the species pool is by using biogeographic data such as species range maps to calculate an assemblage dispersion field (ADF; [Graves & Rahbek., 2005](https://www.pnas.org/content/102/22/7871.long)) centered on the focal site. An ADF considers the species pool to be all species whose range overlaps the range of any species within the focal site. This can often produce excessively large species pools, especially when some species have expansive ranges, therefore a threshold can be introduced so cells which contain ~60% of the same species as the focal cell are included in the species pool thus creating a more restrictive pool. This has the benefit over the sampled species method as it is not restricted to only considering the species that have been observed within a study and can facilitate the testing of community assembly process on studies that survey a narrow environmental gradient in tandem with the many other studies within PREDICTS. 

I will also be looking at the sensitivity of any results to the threshold of the ADF by having a spectrum of species pools for each site. The most restrictive being, only considering the species whose range maps overlaps with the focal site, then increasing the radius of the ADF to the immediate cells around the sites and a slowly decreasing threshold of the ADF to a minimum of 60% similarity. 


## Species-site overlap

Sooooo first things first calculate the first species pool, those whose ranges just overlap with the focal site.

```{r load packages and data}



rm(list = ls())

library(tidyverse) ## for wrangling and general data handling
library(terra) # mapping
library(stars)
library(sp) ## mapping
library(raster) ## mapping
require(sf) ## mapping
require(doParallel) ## parallelisation
require(foreach) ## parallelisation
require(fasterize)

#################
#################

check_output <- function(output_folder, output) {
  value <-  any(grepl(list.files(output_folder), pattern = output))
  return(value)
}

read_file <- function(output_folder, output) {
  file <-
    readRDS(file = grep(
      list.files(output_folder, full.names = TRUE),
      pattern = output,
      value = TRUE
    ))
  return(file)
}


### load in the refined PREDICTS dataset

PREDICTS <- readRDS("../Outputs/refined_predicts.rds")


#### load in a 1 deg raster map that can be converted into a blank raster

#### get a blank world map at a one degree resolution -- approx 100km2 at the equator

  blank <-
    read_file(output_folder = "../Outputs", output = "blank_map_1deg")

```

I am going to extract the coordinates from each of the study sites and using maps from Birdlife extract all those species that overlap 

```{r extract coords, echo=FALSE}


##### get site coordinates

predicts_sites_cells <- function(predicts) {
  sites <-
    predicts %>% dplyr::distinct(SS, SSBS, Longitude, Latitude) %>% data.frame()

  sites[,"cell"] <- terra::cellFromXY(blank, sites[,c("Longitude","Latitude")])
  
    return(sites)
}



spatial_coordinates <- function(LongLat){
  coords <- st_as_sf(SpatialPoints(LongLat[, c("Longitude", "Latitude")], proj4string = CRS("+proj=longlat +datum=WGS84 +no_defs")))
  return(coords)
}

sites <-  predicts_sites_cells(PREDICTS)### 1697 sites in total

### speices maps - species maps are saved for I am going to get all the file_names within the folder to iterate through

species_files <-
  list.files("../../../Datasets/Birdlife_Maps/Shapefiles/PREDICTS_BL/",
             full.names = TRUE)


```

Now equipped with the species maps I am going to collate all the species whose ranges overlap with each site to generate the most restrictive species pool.


```{r create species-site matrix}




########################## create blank matrix row

blank_matrix <- function(rows, columns) {
  mat <-
    matrix(
      rep(NA, length(rows) * length(columns)),
      nrow = length(rows),
      ncol = length(columns),
      dimnames = list(as.character(rows), as.character(columns))
    )
  
  return(mat)
}



########## combine spatial polygons ready for analysis

spatial_combine_polygons <-
  function(geometry) {
    if (any(
      class(geometry$Shape)[1] == "sfc_MULTISURFACE",
      class(geometry$Shape)[1] == "sfc_GEOMETRY"
    )) {
      for (k in 1:NROW(geometry)) {
        geometry$Shape[[k]] <- st_cast(geometry$Shape[[k]], "MULTIPOLYGON")
      }
    }
    
    
    shape <-
      st_combine(geometry$Shape)
    
    
    
    st_crs(shape) <-
      "+proj=longlat +datum=WGS84 +no_defs"
    
    return(shape)
  }

#######################
#######################

filter_polygons <-
  function(BL_data,
           presence_codes,
           seasonal_codes,
           origin_codes) {
    data <-
      BL_data %>% dplyr::filter(presence %in% presence_codes,
                                origin %in% origin_codes,
                                seasonal %in% seasonal_codes)
    return(data)
  }

##################
###################
###################

predicts_species_overlap_matrix <- function(range) {
  data <- readRDS(range) ## load in range
  
  
  #### filter data so that distribution polygons are those that represent extant, probably extant and possibly extant presence,
  #### native, reintroduced and introduced origin and those that are resident, breeding or non-breeding ranges
  sp_name <-
    as.character(data$binomial[1])
  
  
  data <-
    filter_polygons(
      BL_data = data,
      presence_codes = c(1, 2, 3),
      origin_codes = c(1, 2, 3),
      seasonal_codes = c(1, 2, 3)
    )
  
  
  if (nrow(data) == 0) {
    mat <-
      blank_matrix(rows = as.character(sites$SSBS), columns = sp_name)
    
    
    return(mat)
  } else {
    #    ## Sometimes the polygons are in funny classes so coerce into MULTIPOLYGON class
    
    shape <-
      spatial_combine_polygons(data)
    
    
    sf_use_s2(TRUE)
    if (!st_is_valid(shape)) {
      sf_use_s2(FALSE)
    }
    ##create a blank matrix species as columns, sites as rows
    
    mat <-
      matrix(
        rep(NA, nrow(sites)),
        nrow = nrow(sites),
        ncol = 1,
        dimnames = list(as.character(sites$SSBS), as.character(data$binomial)[1])
      )
    ### iterate through sites
    
    
    
    ## calculate overlap this will produce a value of zero if the site lies within it's range
    ### if Overlap = 0 add a 1 to the site indicating presence else a 0
    
    mat[, 1] <-
      ifelse(st_intersects(shape, spatial_coordinates(predicts_sites_cells(PREDICTS)), sparse = FALSE)[1,], 1, 0)
    
    
    return(mat)
  }
}


# register the 8 cores to use while looping

if (check_output("../Outputs", "predicts_species_overlap")) {
  predicts_species_overlap <-
    read_file("../Outputs", "predicts_species_overlap")
} else {
  registerDoParallel(cores = 8)

  predicts_species_overlap <-
    foreach(
      range = species_files,
      ## for each range file
      .packages = c(
        "tidyverse",
        "maptools",
        "rgdal",
        "sp",
        "raster",
        "rgeos",
        "sf"
      ),
      ## required packages
      .combine = "cbind",
      ## how I want the output combined - each iteration will produce a column of a matrix
      .inorder = FALSE
    ) %dopar% {
      # FALSE speeds things up
      
      
      predicts_species_overlap <-
        predicts_species_overlap_matrix(range)
      
      return(predicts_species_overlap)
    }
  
  ### close all conenctions
  #
  registerDoSEQ()
  closeAllConnections()
  
  write_rds("../Outputs/predicts_species_overlap.rds", x =  predicts_species_overlap)
}
### save


site_species_richness <-
  data.frame(
    Site = rownames(predicts_species_overlap),
    spp_rich = rowSums(predicts_species_overlap, na.rm = TRUE)
  )
species_occurences <-
  data.frame(
    Species = colnames(predicts_species_overlap),
    occurrences = colSums(predicts_species_overlap, na.rm = TRUE)
  )


## the number of species just overlapping the site ranges from 59 in Sao Tome and 591 in Uganda - however this will still be restricted with the removal of certain species based on whether they are nocturnal, raptors, swifts or swallows.

head(site_species_richness)

## the most commonly occurring birds is Falco peregrinus almost ubiquitously distributed across all sites in 1518, and the many species that dont occur in any

head(species_occurences)

```


## [Assemblage Dispersion Fields](https://www.pnas.org/content/102/22/7871) 

Assemblage Dispersion Fields (ADF) are typically calculated on a 1 degree resolution raster map [Borregaard et al, 2020](https://www.nature.com/articles/s41467-019-14267-y) so first I am going to create a global map of avian diversity by converting species distribution maps into presence absence cells globally. This can be done by "rasterising" the polygons and then summing all the species rasters.

The rationale for including species with an assemblage dispersion field in the potential species pool for a focal site is that if a good proportion of species from the focal site have been able to disperse to the site from a grid cell then the remainder of the species within the target cell should be able to disperse to the focal cell. This has some very obvious caveats that we will address a little later including differential dispersal capabilities of species and environmental affinities [(Lessard et al, 2012)](https://www.sciencedirect.com/science/article/pii/S016953471200167X).


``` {r map of avian diversity}







#########################
#########################


distribution_matrix <- function(range) {
  data <- readRDS(range)
  
  sp_name <- data$binomial[1]
  
  #### filter data so that distirbution polygons are those that reprsent extant, probably extnat and possibly extant presence,
  #### native, reintroduced and introduced origin and those that are resident, breeding or non-breeding rnages
  
  data <-
    filter_polygons(
      BL_data = data,
      presence_codes = c(1, 2, 3),
      origin_codes = c(1, 2, 3),
      seasonal_codes = c(1, 2, 3)
    )
  
  if (nrow(data) == 0) {
    mat <- blank_matrix(columns = blank@data@values, rows = sp_name)
    
    return(mat)
  } else {
    
    
    shape <- st_as_sf(spatial_combine_polygons(data))
    
    
  
    ### convert polygon into a presence raster on the blank world map
    
    #
    # try(ras <-  raster::rasterize(x = shape, y = blank, getCover = TRUE,background = NA),silent = TRUE)
    # ras@data@values <- ifelse(ras@data@values >= 0.1, 1,0)
    
    
    ras <-
      fasterize::fasterize(
        sf = shape,
        raster = blank,
        fun = "count",
        background = 0
      )
    
    #### extract cells which overlap with the polygon and exclude marine and oceanic ranges by adding blank map
    #### that has non-terrestrial cells as NA
    
    ras_data <- (blank + ras)
    
        #### create matrix where the row is the species and each column is a cell in the raster - presence indicated by a 1
    
    
    mat <-
      matrix(
        ras_data,
        nrow = 1,
        ncol = length(ras_data),
        dimnames = list(sp_name, c(1:length(ras_data)))
      )
    
    return(mat)
  }
  
}



if (check_output(output_folder = "../Outputs", output = "raster_species_matrix")) {
  bird_distribution_data <-
    read_file(output_folder = "../Outputs", output = "raster_species_matrix")
} else {
  registerDoParallel(cores = 8)
  
  bird_distribution_data <- foreach(
    range = species_files,
    .combine = "rbind",
    .packages = c(
      "tidyverse",
      "maptools",
      "rgdal",
      "sp",
      "raster",
      "rgeos",
      "sf",
      "fasterize"
    ),
    .inorder = FALSE
  ) %dopar% {
    bird_distribution_matrix <- distribution_matrix(range)
    return(bird_distribution_matrix)
  }
  
  registerDoSEQ()
  closeAllConnections()
  
  ## save output map data that can then be put given to the blank raster
  write_rds(x = bird_distribution_data, file = "../Outputs/raster_species_matrix.rds")
}


spp_rich_df <-
  data.frame(
    Cell = colnames(bird_distribution_data),
    spp_rich = colSums(bird_distribution_data, na.rm = TRUE)
  )

diversity <- blank

diversity@data@values <- (blank@data@values + spp_rich_df$spp_rich)

plot(diversity)


```

With this diversity matrix with the species as rows and cells as columns we can then can the similarity between any two cells. Using this principle I can then begin to calculate the assemblage dispersion fields for each of the sites within PREDICTS. First by locating which cell each site is in and then calculating the similarity of every other cell. 

```{r focal cell similarity}

########################################################
###### PREDICTS SITES ASSEMBLAGE SIMILARITY MATRIX #####
########################################################




#### Which cell is each site located in

get_species_from_cell <- function(cell){
  species <-  names(which(bird_distribution_data[, cell] == 1))
  return(species)
}


## This loop is going to create a matrix with rows being the cell in which a site is located and columns being all other raster cells
## the value of each cell will the proportion of species shared between each cell

site_cells <- unique(sites$cell)


species_in_all_cells <- lapply(1:ncol(bird_distribution_data), get_species_from_cell)


species_cell_similarity <- function(species,cell){
  
  if(is_empty(species_in_all_cells[[cell]])) {
        return(NA)
  } else {
  
  other_spp <- species_in_all_cells[[cell]]
        
        ### if the cell is terrestrial but has no species in it then the other species is none
        
        if (is_empty(other_spp)) {
          other_spp <- "none"
        }
        
        ### how many species are shared between the two cells
        
        sim <- length(which(species %in% other_spp))
        
        # if none similarity is 0
        
        
        return(ifelse(sim != 0, sim / length(species), 0))
  }
}


adf_similarity_function <- function(cells, island = FALSE) {
  mat <-
    matrix(rep(NA, ncol(bird_distribution_data)),
           nrow = 1,
           ncol = ncol(bird_distribution_data), 
           dimnames = list(cells,1:ncol(bird_distribution_data)))

  #####
  
  
  if(island){
    
      coords <-
    spatial_coordinates(sites %>% dplyr::filter(new_cell == cells) %>% dplyr::distinct(Longitude, Latitude) %>% slice(1))
  
  
  
  ## extract species that are present within a specified cell for the island form the focal cell species will be all species overlaping with that island
  
  for (island in names(island_polys)) {
    isle_poly <- st_as_sf(island_polys[[island]])
    st_crs(isle_poly) <- st_crs(coords)
    if (as.numeric(st_distance(coords, isle_poly)[1, 1]) < 100) {
      focal_spp <- island_spp[[island]]
      break()
    }
  }
  } else {

    ## extract species that are present within a specified cell
    focal_spp <- species_in_all_cells[[cells]]
  }
    ### get all other cells minus the focal cell
    
    other_cells <-
      c(1:length(species_in_all_cells))[-cells]
    
    
    ## cell shares all species with itself
    
    mat[, cells] <- 1
    
    ### for all other cells extract species and calculate proportion of pseices shared with focal cell
    
    for (other in other_cells) {
      ### if there are no species in the cell and they're all NA then the proportion of similar species is zero obvs
      
      
      
      mat[, other] <- species_cell_similarity(species = focal_spp,cell = other)
    }
    
  
  
  return(mat)
}


if (check_output(output_folder = "../Outputs", output = "assemblage_dispersion_field_similarity_matrix")) {
  adf_similarity_matrix <-
    read_file(output_folder = "../Outputs", output = "assemblage_dispersion_field_similarity_matrix")
} else {
  registerDoParallel(cores = 5)
  
  adf_similarity_matrix <- foreach(
    cell = site_cells,
    .combine = "rbind",
    .packages = c("tidyverse", "raster", "maptools", "rgeos", "sf", "sp"),
    .inorder = FALSE
  ) %dopar% {
    adf_sim <- adf_similarity_function(cells = cell)
    
    
  }
  
  registerDoSEQ()
  closeAllConnections()
  
  write_rds(file = "../Outputs/assemblage_dispersion_field_similarity_matrix.rds", x = adf_similarity_matrix)
}


```

The resulting matrix will have the proportion of species shared between the focal cell. So now we can begin to visualize the shapes of these dispersion fields and the area from which we are going to be extracting our species pool from. 


```{r adfs}
dir.create("../Outputs/assemblage_dispersion_fields")

for (i in 1:nrow(adf_similarity_matrix)) {
  ### get the studies which have sites within this cell
  print(i)
  study <-
    sites %>% filter(cell == rownames(adf_similarity_matrix)[i]) %>% distinct(SS) %>% pull()
  study <- paste(study, collapse = "&")
  
  # create a directory
  
  dir <-
    paste("../Outputs/assemblage_dispersion_fields/",
          paste(study, i, sep = "_"),
          sep = "")
  
  #dir.create(dir)
  
  ## get each of the cell similarity scores
  
  adf <- adf_similarity_matrix[i, ]
  
  ## input into blank raster
  
  adf_map <- blank
  
  adf_map@data@values <- adf
  
  ### save the raw similarity scores
  
  png(paste(dir, "/", "adf.png", sep = ""))
  plot(adf_map)
  dev.off()
  
  
  ### which cells are above the threshold for similarity
  
  for (sim in c(0.9, 0.8, 0.7, 0.6)) {
    ## save the resulting map indicating the cells whose species will be included in the species pool.
    
    png(paste(dir, "/", sim, ".png", sep = ""))
    plot(adf_map > sim)
    dev.off()
  }
  
}

plot(adf_map)

plot(adf_map > 0.6)
plot(adf_map > 0.7)
plot(adf_map > 0.8)
plot(adf_map > 0.9)


```

After this I would like to see how many species each of these thresholds generally include in there ADF, as obviously the lower the threshold the more species that are going to be included and this can influence the inferences of an anylsis as teh larger the species pool the more likely you are to find a difference between the observed and the null communities [(Cornell & Harrison, 2014)](https://www.annualreviews.org/doi/abs/10.1146/annurev-ecolsys-120213-091759).

``` {r ADF richness}

######## This function checks to see how many species are incorporate into the adf depending on the threshold for cell similarity from 0.1 to 11


adf_spp_rich <- function(cells, data) {
  ## create a blank matrix with 11 rows (seq(0,1,0.1)) and the amount of columns of the cells to check
  
  
  sequence <- seq(0,1,0.1)
  
  adf_nspp <-
    matrix(
      rep(NA, 11 * length(cells)),
      nrow = 11,
      ncol = length(cells),
      dimnames = list(as.character(sequence), as.character(cells))
    )
  
  ### for each cell and proportion combination
  
  for (cell in cells) {
    for (prop in sequence) {
      prop_cells <- which(data[as.character(cell), ] > prop)
      
      
      adf_nspp[as.character(prop), as.character(cell)] <- length(unique(unlist(species_in_all_cells[prop_cells])))
    }
  }
  return(adf_nspp)
}

#### run funciton for all our site focal cells

adf_richness <- adf_spp_rich(site_cells, adf_similarity_matrix)

adf <- blank

adf@data@values <- adf_similarity_matrix["32227", ]


plot(adf)

```
Here we can see that some of the focal cells for some of our sites are predominately in the ocean so are picking up oceanic and palegic species in the similarity analysis, so I am going to identify the problem cells and reassign the focal cell to the surrounding cell which has the most similar species to those that directly overlap with the site coordinates.  

The problem cells can be easily identified with the number of species that are present within the unrestricted adf.

``` {r resolve problem cells}

  problem_cells <- c(as.numeric(names(which(adf_richness[1,] < 9000))),30881)



  resolve_problem_cells <- function(problem_cells){
    
    predicts_data <- predicts_sites_cells(PREDICTS)
    predicts_data$new_cell <- predicts_data$cell
    
    
    for(problem_cell in problem_cells){
    
    problem_site <- predicts_data %>% dplyr::filter(cell == problem_cell) %>% dplyr::distinct(SSBS) %>% pull() %>% as.character()
    problem_site <- problem_site[1]
    
     ## what are the species overlapping the site 
    
    prob_spp <- names(which(predicts_species_overlap[problem_site,] == 1))
    
    ### get the surround cells  
    
    surround <- adjacent(blank, problem_cell, directions = 8 )[,2]
    
    
    ### for each of the surrounding cells 
    
    sound_prob <- c()
    
    for(s_cell in surround){
      
      ### what species are within
      
      sound_spp <-  species_in_all_cells[[s_cell]] 
      
      ### calculate similarity between surrounding cell and site
      
      sound_sim <- length(which(prob_spp %in% sound_spp))/length(prob_spp)
      
      # store
      
      sound_prob <- c(sound_prob,sound_sim)
      
    }
    
    # which of the surrounding cells has teh greatest similarity
    
    solve_cell <- surround[which.max(sound_prob)]
    
    ## reassign
    
    
    predicts_data <- predicts_data %>% dplyr::mutate(new_cell = ifelse(cell == problem_cell, as.numeric(solve_cell), new_cell))
    }
    
    
    return(predicts_data)
    
  
  }
  
  sites <- resolve_problem_cells(problem_cells)
  sites <- sites %>% dplyr::mutate(new_cell = ifelse(SSBS == "FB1_2007a_Barlow 1 1", 32528, new_cell))
  

  

```

Soo hopefully now the problem cells have been resolved can re-do the species-threshold check

```{r re-do}


## new cells


new_cells <- unique(sites$new_cell)


#### add new cells to the adf_similarity_matrix

add <- new_cells[which(!(new_cells %in% site_cells))]




new_mat <- c()
for (a in add) {
  m <- adf_similarity_function(cells = a)
  new_mat <- rbind(new_mat, m)
}


adf_similarity_matrix <- rbind(adf_similarity_matrix, new_mat)


## run the cell richness function again

adf_richness <- adf_spp_rich(new_cells, adf_similarity_matrix)


##### the persistent problem cells are those of the studies on small islands, such a sao tome and principe, puerto rico and comoros

problem_cells <- as.numeric(names(which(adf_richness[1, ] < 9000)))




############################################
############################################
############################################
############################################
############################################

island_polys <- readRDS("../Outputs/assembly_islands.rds")
island_spp <- readRDS("../Outputs/assembly_island_spp.rds")



for (prob in problem_cells) {
  m <- adf_similarity_function(prob, island = TRUE)
  adf_similarity_matrix[as.character(prob), ] <- m
}


adf_similarity_matrix <-
  adf_similarity_matrix[!duplicated(rownames(adf_similarity_matrix)), ]
write_rds(file = "../Outputs/assemblage_dispersion_field_similarity_matrix.rds", x = adf_similarity_matrix)

sites <-
  sites %>% dplyr::mutate(problem_cells = ifelse(new_cell %in% problem_cells, TRUE, FALSE))
write_rds(file = "../Outputs/adf_sites_frame.rds", sites)



for (i in problem_cells) {
  ### get the studies which have sites within this cell
  
  study <-
    sites %>% filter(new_cell == i) %>% distinct(SS) %>% pull()
  study <- paste(study, collapse = "&")
  
  # create a directory
  
  dir <-
    paste("../assemblage_dispersion_fields/",
          paste(study, i, sep = "_"),
          sep = "")
  
  dir.create(dir)
  
  ## get each of the cell similarity scores
  
  adf <- adf_similarity_matrix[as.character(i), ]
  
  ## input into blank raster
  
  adf_map <- blank
  
  adf_map@data@values <- adf
  
  ### save the raw similarity scores
  
  png(paste(dir, "/", "adf.png", sep = ""))
  plot(adf_map)
  dev.off()
  
  ### which cells are above the threshold for similarity
  
  for (sim in c(0.9, 0.8, 0.7, 0.6)) {
    ## save the resulting map indicating the cells whose species will be included in the species pool.
    
    png(paste(dir, "/", sim, ".png", sep = ""))
    plot(adf_map > sim)
    dev.off()
  }
  
}




adf <- blank

adf@data@values <-
  blank@data@values + adf_similarity_matrix["32587", ]

plot(adf)

```


## Excluding species from the species pools

Certain species are going to need to be excluded form the species pool depending on their life history because it is unlikely they would have been observed during the surveying or if they were it is unlikely that they are resident in habitat and therefore not going to be impacted by the land use. Excluded species include:

- Nocturnal species

- Marine species

- Coastal species

- swifts - aerial 

- swallows - aerial

- martins - aerial 

- raptors - aerial 


```{r excluding species}

## READ in AVONET and make sure some taxonomic discrepancies are resovled.

AVONET <- read.csv("../../../Datasets/GBD/GBD_2021_BirdLife_Taxo_19 April.csv") %>%
  dplyr::mutate(Birdlife_Name = ifelse(Birdlife_Name == "Gorsachius magnificus", "Oroanassa magnifica", paste(Birdlife_Name)),
                Birdlife_Name = ifelse(Birdlife_Name == "Psittacula krameri", "Alexandrinus krameri", paste(Birdlife_Name)),
                Birdlife_Name = ifelse(Birdlife_Name == "Arachnothera hypogrammica", "Kurochkinegramma hypogrammica", paste(Birdlife_Name)),
                Birdlife_Name = ifelse(Birdlife_Name == "Psittacula eupatria", "Palaeornis eupatria", paste(Birdlife_Name)),
                Birdlife_Name = ifelse(Birdlife_Name == "Psittacula finschii", "Himalayapsitta finschii", paste(Birdlife_Name)),
                Birdlife_Name = ifelse(Birdlife_Name == "Psittacula roseata", "Himalayapsitta roseata", paste(Birdlife_Name)),
                Birdlife_Name = ifelse(Birdlife_Name == "Psittacula longicauda", "Belocercus longicaudus", paste(Birdlife_Name)),
                Birdlife_Name = ifelse(Birdlife_Name == "Hapalocrex flaviventer", "Laterallus flaviventer", paste(Birdlife_Name)),
                Birdlife_Name = ifelse(Birdlife_Name == "Hylocharis chrysura", "Amazilia chrysura", paste(Birdlife_Name)),
                Birdlife_Name = ifelse(Birdlife_Name == "Porzana spiloptera", "Laterallus spilopterus", paste(Birdlife_Name)),
                Birdlife_Name = ifelse(Birdlife_Name == "Hylocharis cyanus", "Amazilia cyanus", paste(Birdlife_Name)),
                Birdlife_Name = ifelse(Birdlife_Name == "Chrysuronia oenone", "Amazilia oenone", paste(Birdlife_Name)),
                Birdlife_Name = ifelse(Birdlife_Name == "Hylocharis eliciae", "Amazilia eliciae", paste(Birdlife_Name)),
                Birdlife_Name = ifelse(Birdlife_Name == "Juliamyia julie", "Amazilia julie", paste(Birdlife_Name)),
                Birdlife_Name = ifelse(Birdlife_Name == "Lepidopyga goudoti", "Amazilia goudoti", paste(Birdlife_Name)),
                Birdlife_Name = ifelse(Birdlife_Name == "Lepidopyga coeruleogularis", "Amazilia coeruleogularis", paste(Birdlife_Name)),
                Birdlife_Name = ifelse(Birdlife_Name == "Psittacula himalayana", "Himalayapsitta himalayana", paste(Birdlife_Name)),
                Birdlife_Name = ifelse(Birdlife_Name == "Psittacula columboides", "Nicopsitta columboides", paste(Birdlife_Name)),
                Birdlife_Name = ifelse(Birdlife_Name == "Psittacula cyanocephala", "Himalayapsitta cyanocephala", paste(Birdlife_Name)),
                Birdlife_Name = ifelse(Birdlife_Name == "Psittacula calthrapae", "Nicopsitta calthrapae", paste(Birdlife_Name)),
                Birdlife_Name = ifelse(Birdlife_Name == "Psittacula eques", "Alexandrinus eques", paste(Birdlife_Name)),
                Birdlife_Name = ifelse(Birdlife_Name == "Lepidopyga lilliae", "Amazilia lilliae", paste(Birdlife_Name)),
                Birdlife_Name = ifelse(Birdlife_Name == "Heteroglaux blewitti", "Athene blewitti", paste(Birdlife_Name)),
                Birdlife_Name = ifelse(Birdlife_Name == "Atlantisia rogersi", "Laterallus rogersi", paste(Birdlife_Name)),
                Birdlife_Name = ifelse(Birdlife_Name == "Psitteuteles iris", "Trichoglossus iris", paste(Birdlife_Name)))

## read in the Foraging dataset 

Forage <- readRDS("../../PREDICTS_Taxonomy/PREDICTS_imputed_BL_traits_forage.rds")

### extract all the species that have been flagged for exclusion
Nocturnal_spp <- AVONET %>% dplyr::filter(Nocturnal == 1) %>% pull(Birdlife_Name)
marine_spp <- AVONET %>% filter(Primary_Habitat_updated == "Marine") %>% pull(Birdlife_Name)
swift_spp <- AVONET %>% filter(Birdlife_family %in%  c("Apodidae","Hemiprocnidae")) %>% pull(Birdlife_Name)
swallow_spp <- AVONET %>% filter(Birdlife_family %in% c("Hirundinidae","Artamidae")) %>% pull(Birdlife_Name)
raptor_spp <- AVONET %>% filter(Birdlife_family %in% c("Accipitridae","Cathartidae","Falconidae")) %>% pull(Birdlife_Name)
coastal_spp <- AVONET %>% filter(Primary_Habitat_updated == "Coastal") %>% pull(Birdlife_Name)
Extinct_spp <- AVONET %>% filter(is.na(Extinct..Yes.1..No.0.)) %>% pull(Birdlife_Name)
Extinct_spp <- unique(c(Extinct_spp,"Pinguinus impennis","Conuropsis carolinensis","Ectopistes migratorius","Camptorhynchus labradorius","Psephotellus pulcherrimus","Ara tricolor","Chenonetta finschi","Coturnix novaezelandiae","Ixobrychus novaezelandiae","Mergus australis","Sceloglaux albifacies","Tribonyx hodgenorum","Turnagra capensis","Xenicus longipes","Coenocorypha barrierensis","Heteralocha acutirostris","Porphyrio mantelli","Turnagra tanagra","Podiceps andinus","Tachybaptus rufolavatus","Ophrysia superciliosa","Anas marecula","Bulweria bifax","Alopochen mauritiana","Columba jouyi","Coua delalandei","Falco duboisi","Moho braccatus","Himatione fraithii"))

drop_spp <- unique(c(Nocturnal_spp,marine_spp,swift_spp,swallow_spp,raptor_spp,coastal_spp,Extinct_spp, "Accipiter_1","Aerodramus_1","Aerodramus_2","Chaetura_1","Apus_1","Collocalia_1"))

### excluding 1385 species from inclusion in the species pool. 

write_rds(file = "../Outputs/assembly_drop_spp.rds", drop_spp)

```

I am going to define a spectrum of species pools from the most restrictive to just the species whose ranges overlaps the site coordinates and then just those species that occur in the immediate surrounding cells. Then the rest are adf species rnging from a similarity threshold of 0.6 to 0.9. 



``` {r species pools}



drop_species <- function(species) {
  species <- species[!(species %in% drop_spp)]
  return(species)
}

### species poool function that has the input of the focal site




site_species <- function(site) {
  site_spp <-
    PREDICTS %>% dplyr::filter(SSBS == site,!pseudospp) %>% distinct(Birdlife_Name) %>% pull()
  
  ## site overlap extraction
  
  site_spp <-
    drop_species(unique(c(names(
      which(predicts_species_overlap[site, ] == 1)
    ), site_spp)))
  
  return(site_spp)
}


surround_species <- function(cell, site) {
  if (cell %in% problem_cells) {
    coords <-
      spatial_coordinates(sites %>% dplyr::filter(SSBS == site) %>% dplyr::distinct(Longitude, Latitude))
    
    for (island in names(island_polys)) {
      island_pol <- st_as_sf(island_polys[[island]])
      st_crs(island_pol) <- st_crs(coords)
      
      ## find out which island
      if (as.numeric(st_distance(coords, island_pol)[1, 1]) < 1000) {
        surround_spp <- drop_species(island_spp[[island]])
        
        ## stop looop once assigned
        break()
      }
    }
    
    
  } else {
    surround_cells <-
      unique(c(cell, adjacent(
        cell, x = blank, directions = 8
      )[, 2]))
    
    #the species that contained within those cells
    
    surround_spp <-
      drop_species(unique(unlist(species_in_all_cells[surround_cells])))
    
  }
  
  return(surround_spp)
  
}



proportion_species <- function(prop, cell, site) {
  ### get the cells which surpass the threshold of similarity
  prop_cells <-
    which(adf_similarity_matrix[as.character(cell), ] > prop)
  
  if (cell %in% problem_cells) {
    ## if there are less that two cells so it would be cell the single focal cell assign all the species on the island
    prop_species <-
      unique(c(surround_species(cell), site_species(site)))
  } else {
    # species that occur within a single cell - random that this needs to be done but rowSums doesn't work when there's just a single cell
    prop_species <-
      drop_species(unique(c(unique(
        unlist(species_in_all_cells[prop_cells])
      ))))
    
  }
  return(prop_species)
}

species_pool_func <- function(site) {
  
  
  ### create a list on item for each of the species pools
  spp_pool_list <- c(rep(list(NA), 6))
  
  ### name them
  names(spp_pool_list) <-
    c("0.6", "0.7", "0.8", "0.9", "surround", "site_overlap")
  
  
  ### each species pool should always have the species that were observed in the study which after begin validated indicates a definite abiility to colonise the site regardless of species maps -- excluding the generated pseudospp from the range validation
  
  # PREDICTS extraction
  
  
  site_spp <- site_species(site)
  
  ### assign species
  
  spp_pool_list[["site_overlap"]] <- site_spp
  
  
  ## now we need to pull the cell in which the site occurs
  
  site_cell <-
    sites %>% dplyr::filter(SSBS == site) %>% dplyr::distinct(new_cell) %>% pull()
  
  ## if the cell is part of the problem cells which are on islands teh species pools need to be defined in a slightly different way
  
  
  surround_spp <-
    unique(c(site_spp, surround_species(site_cell, site)))
  
  spp_pool_list[["surround"]] <- surround_spp
  
  
  for (prop in c(0.6, 0.7, 0.8, 0.9)) {
    prop_spp <-
      unique(c(
        site_spp,
        proportion_species(
          prop = prop,
          cell = site_cell,
          site = site
        )
      ))
    
    spp_pool_list[[as.character(prop)]] <- prop_spp
    
  }
  
  
  return(spp_pool_list)
  
}

## the sites
sp_pool_sites <- as.character(unique(sites$SSBS))

# blank list

species_pools <- lapply(sp_pool_sites, species_pool_func)
names(species_pools) <- sp_pool_sites

#save

write_rds(file = "../Outputs/predicts_sites_species_pools.rds", species_pools)

```

## Further refining the species pool 

[Lessard et al, 2012](https://www.sciencedirect.com/science/article/pii/S016953471200167X)'s paper "Inferring local ecological processes amid species pool influences" suggests various ways of defining the species pool to detect non-random processes of assembly and highlights the utility of making the definition ecologically explicit to impart as much realism as possible. Much of the idiosyncrasy in community ecology arises as a result 
of geographic variation in the evolutionary and historical processes that have shaped the structure of the species pool. As such, species pools need to take into account the ecological processes that may influence the structure of the species pool, such as species dispersal capabilities and environmental affinity for a specific location.   

These ecological contingencies can be accounted for when performing null model analyses by weighting the probability of a species' traits being selected by species-specific dispersal and environmental probabilities. 

### Dispersal probability

Recently the Hand-Wing Index (HWI) has been adopted as a proxy for dispersal ability in birds [Sheard et al, 2020](https://www.nature.com/articles/s41467-020-16313-6#MOESM1) with larger HWI values being associated with a greater dispersal capability. Therefore a potential metric for dispersal probability could look like (HWI)/(distance to range edge).

```{r Dispersal probabilities}




assembly_species <- unique(c(unlist(unlist(species_pools))))


index_list_sp <- function(list){
  pool_sp <- c()
  for(i in 1:length(list)){
    pool_sp <- unique(c(pool_sp,list[[i]]))
  }
  return(pool_sp)
}


 

site_find <- function(sp){
  sp_site <- c()
  
  for(i in 1:length(species_pools)){
    pool_sp <- index_list_sp(species_pools[[i]])
    
    if(sp %in% pool_sp){
      sp_site <- c(sp_site,names(species_pools)[i])
    }
  }
  return(sp_site)
}

polygon_from_species <- function(species){
  data <- readRDS(grep(species_files, pattern = paste("/",species,"Birdlife",sep = ""), value = TRUE))
  return(data)
}


distance_to_range_edge_function <- function(species) {
  mat <-
    matrix(rep(NA, length(species_pools)),
           ncol = 1,
           dimnames = list(names(species_pools), species))
  
  data <-
    filter_polygons(
      BL_data = polygon_from_species(species),
      presence_codes = c(1, 2, 3),
      seasonal_codes = c(1, 2, 3),
      origin_codes = c(1, 2, 3)
    )
  
  shape <- spatial_combine_polygons(data)
  
  
  sf_use_s2(TRUE)
  if (!st_is_valid(shape)) {
    sf_use_s2(FALSE)
  }
  
  
  
  sp_sites <- site_find(species)
  
  
  s_coords <-
    coords %>% dplyr::filter(SSBS %in% sp_sites)
  rownames(s_coords) <- s_coords$SSBS
  s_coords <- spatial_coordinates(s_coords[sp_sites,])
   
  
  mat[sp_sites, sp] <-
    as.numeric(st_distance(s_coords, shape))
  
  return(mat)
  
  
}


coords <- predicts_sites_cells(PREDICTS)


if( check_output(output_folder = "../Outputs",output = "distance_to_range_edge")){
  distance_to_range_edge <- read_file(output_folder = "../Outputs",output = "distance_to_range_edge")
} else {


 registerDoParallel(cores = 8)
 
 distance_to_range_edge <- foreach(sp = assembly_species,
                     .combine = "cbind",
                     .packages = c("tidyverse", "maptools", "rgdal", "sp", "raster","rgeos","sf","fasterize"),
                     .inorder = FALSE) %dopar% {
                       
                         
            dist_range_edge <- distance_to_range_edge_function(sp)
            return(dist_range_edge)
 
 }
 
 registerDoSEQ()
 closeAllConnections()
 
 write_rds(distance_to_range_edge, file = "Outputs/distance_to_range_edge.rds")

}
 
registerDoSEQ()


traits <- readRDS("../../PREDICTS_Taxonomy/PREDICTS_imputed_BL_traits.rds") 



## higher the hand wing index the greater the probability of selection + 
## the further away the range edge the lower the probability of selection
hand_wing_index <- traits$Hand.Wing.Index
names(hand_wing_index) <- traits$uniqueIDS


# soooooooooooooooo if dist to range edge probability should be 1 and then the greater the distance the lower the probability modulated by HWI
### 



dispersal_probability_matrix <- function(dist_to_range, hand_wing_index){
  scale_dist_to_range <- dist_to_range/max(dist_to_range, na.rm = TRUE)
  scale_HWI <- hand_wing_index/max(hand_wing_index, na.rm = TRUE)
  
  for(species in colnames(dist_to_range)){
    HWI <- as.numeric(scale_HWI[species])
    
    scale_dist_to_range[,sp] <- 1 - pgamma(q = dispersal_prob[,sp], shape = HWI)
  }
  
  return(scale_dist_to_range)
}


dispersal_probability <- dispersal_probability_matrix(dist_to_range = distance_to_range_edge, hand_wing_index = hand_wing_index)


## Hand_wing index scaled between 0 and 1
 
plot(1-sapply(seq(0,1,0.01),function(x) pgamma(q = x,shape = 0.4)))

sapply(seq(0,1,0.01),function(x) pgamma(x,shape = 0.5))

write_rds(dispersal_prob, file = "Outputs/sp_dispersal_probabilities.rds")

```

### Environmental affinity

An ideal approach for estimating species specific environmental affinities would be to quantify directly habitat requirements and phsiological limits (potentially by performing species distribution modelling whose output is a probability of presence based on the environmental conditions at a cell). I think that these maps may be available from Stephen Willis in Durham so will need to ask Joe about these. Lessard cautions against using the same data to derive environmental affinities as used for delineating the species pool to avoid the risk of circular reasoning so getting these projections would be useful as they'll defintely be based on new data.

```{r environmental affinities}




crosswalk <-
  read.csv("../../../PhD_Code/PREDICTS_Taxonomy/BL_Jetz crosswalk v3.csv")

# get the list of files that have the model outputs - in the methodology species that occupied fewer that 10 grid cells were excluded from
# the analysis so I'm going to need to come up with something to do about those.

SDM_sp <-
  list.files("../../../Datasets/Bird_SDM_Projections_Probability/")

## get just species names
sp <-
  gsub(
    x = gsub(
      x = SDM_sp,
      replacement = "",
      pattern = "\\.rds"
    ),
    pattern = "_",
    replacement = " "
  )

sdm_species <- data.frame(Birdlife_Name = sp)



resolve_species <-
  read.csv("../../../Datasets/Bird_SDM_Projections_Probability/Miss_sp.csv")


##### I'm just going to be looking at the environmental affinities for those species in the 0.9 species pools
##### this is because this is the species pool I am initially going on with and then I had to do less manual resolutions of mismatched species

assembly_species <- c()
for (i in 1:length(species_pools)) {
  assembly_species <-
    unique(c(assembly_species, species_pools[[i]][["0.9"]]))
}




sites <- rownames(distance_to_range_edge)





######
###### So given that the SDM files does not fully cover the assembly species with the update taxonomy the three years since the inital analysis was performed there are a few different pathways to get the environmental affinty of a species to a site. First its easy when the species is present just need to transform site coordinates and extract the probability of presense given the environmental variables.
###### Second if teh taxonomy has changed since the stduy was perfromed I was able to detct changes and point the species to a potential surrogate and then just load that SDM and extract the probability
###### Third if a species has split into multiple since I've taken the mean probability of presence of the three sister taxon
###### Fourth if there is no map, often due to too few cells being occupied to perform the analysis, probability of presence doesn't really come into it, if the site overlaps with the study site the probability is one and else zero.

## for species in teh assembly pool

SDM_data_from_species <- function(species) {
  string <- grep(
    list.files(
      "../../../Datasets/Bird_SDM_Projections_Probability/",
      full.names = TRUE
    ),
    pattern = paste(gsub(
      species,
      pattern = " ",
      replacement = "_"
    ),
    ".rds",
    sep = ""),
    value = TRUE,
    ignore.case = FALSE
  )
  
  
  return(string)
}
####################################
#####################################

extract_predicts_sites_LongLat <- function(predicts, sites) {
  data <-
    predicts %>% dplyr::filter(SSBS %in% sites) %>% dplyr::distinct(SSBS, Longitude, Latitude)
  
  return(data)
  
}

#####################

too_few_cell_species <- function(sp) {
  sp_poly <-
    spatial_combine_polygons(
      filter_polygons(
        BL_data = polygon_from_species(sp),
        presence_codes = c(1, 2, 3),
        seasonal_codes = c(1, 2, 3),
        origin_codes = c(1, 2, 3)
      )
    )
  
  ## filter ranges
  
  
  if (!st_is_valid(sp_shape)) {
    sf_use_s2(FALSE)
  }
  
  
  sp_sites <- site_find(sp)
  
  # get coordinates
  
  sp_sites <-
    spatial_coordinates(
      PREDICTS %>% dplyr::filter(SSBS %in% sp_sites) %>% distinct(SSBS, Longitude, Latitude)
    )
  
  
  return(ifelse(st_intersects(sp_shape, site_coords, sparse = FALSE)[1,],
                1,
                0))
  
}

##########################
###########################
###########################

mean_species_environmental_affinity <- function(sp) {
  split_sp <-
    crosswalk %>% dplyr::filter(BirdLife.name == sp) %>% pull(Jetz.name)
  split_sp <-
    crosswalk %>% dplyr::filter(Jetz.name == split_sp) %>% pull(BirdLife.name)
  split_sp <-
    split_sp[which(split_sp %in% sdm_species$Birdlife_Name)]
  
  ## find the sites that the original species occurs in the species pools
  
  sp_sites <- site_find(sp)
  
  ## for each of those sites
  
  
  
  #get coords
  
  s_coords <-
    coords %>% dplyr::filter(SSBS %in% sp_sites) %>% dplyr::select(-SSBS) %>% SpatialPoints(proj4string = CRS("+proj=longlat +datum=WGS84 +no_defs")) %>% st_as_sf() %>% st_transform(crs = "+proj=cea +lat_ts=30")
  
  # empty vector for probability of presence vals
  
  mean_vals <- c()
  
  # for each species
  
  for (i in 1:length(split_sp)) {
    # load the map
    
    
    
    sp_file <- SDM_data_from_species(split_sp[i])
    
    
    data <- readRDS(sp_file)
    
    # make raster
    
    sp_ras <-
      rasterFromXYZ(xyz = data[, c("lon", "lat", "current")], crs = "+proj=cea +lat_ts=30")
    
    # extract probability of presence
    
    val <- matrix(extract(x = sp_ras, y = s_coords), ncol = 1)
    
    # join mean to vector
    
    mean_vals <- cbind(mean_vals, val)
  }
  
  return(rowMeans(mean_vals, na.rm = TRUE))
  
  
}


environmental_probability_matrix <- function(species){
  
  mat <-
  matrix(
    rep(NA, length(sites) * 1),
    nrow = length(sites),
    ncol = 1,
    dimnames = list(sites, species)
  )
  
  if (species %in% resolve_species$Birdlife_Name) {
    ## get that species data
    
    res_dat <-
      resolve_species %>% dplyr::filter(Birdlife_Name == species)
    
    ## if the species is set to be dropped due to too few cells often or for two species quite mysterious reasons
    
    ###########################
    ################ SCENAIO 4
    ###########################
    
    if (res_dat$DROP) {
      ### load in the species poly
      
      
      
      ## if the site overlaps with the species range code as 1 else 0
      
      mat[site_find(species), species] <-
        too_few_cell_species(species)
      
      
      
      sf_use_s2(TRUE)
      #skip
      
      next()
    }
    
    
    
    
    
    
    ###########################
    ################ SCENAIO 2
    ###########################
    
    # if the species wasn't do be dropped and there was a single species it could translate to then just point to that species file in the
    # folder
    
    if (!res_dat$DROP & res_dat$potential_species != "Mean") {
      # extract the file name
      
      sp_file <- SDM_data_from_species(res_data$potential_species)
      
    }
    
    
    
    ###########################
    ################ SCENAIO 3
    ###########################
    
    ###### if it is the mean species then get the sister species from the crosswalk and those that SDM data is available.
    
    else {
      mat[sp_sites, species] <-
        mean_species_environmental_affinity(species)
      
      
      
      next()
    }
  }
  
  
  
  
  
  else {
    sp_file <- SDM_data_from_species(species)
  }
  
  
  data <- readRDS(sp_file)
  
  
  sp_ras <-
    rasterFromXYZ(xyz = data[, c("lon", "lat", "current")], crs = "+proj=cea +lat_ts=30")
  
  
  
  sp_sites <- site_find(species)
  
  s_coords <- extract_predicts_sites_LongLat(predicts = coords, sites = sp_sites)
  
  rownames(s_coords) <- s_coords$SSBS
  
  s_coords <-
    s_coords[sp_sites, ] %>% dplyr::select(-SSBS) %>% SpatialPoints(proj4string = CRS("+proj=longlat +datum=WGS84 +no_defs")) %>% st_as_sf() %>% st_transform(crs = "+proj=cea +lat_ts=30")
  
  
  environ_p <- extract(x = sp_ras, y = s_coords)
  
  mat[sp_sites, species] <- 
    extract(x = sp_ras, y = s_coords)
  
  ######################
  ######################
  ######################
  
  
  if (any(environ_p == 0)) {
    zero_site <- sp_sites[which(environ_p == 0)]
    
    sp_poly <-
      readRDS(grep(
        species_files,
        pattern = paste("/", sp, "Birdlife", sep = ""),
        value = TRUE
      ))
    
    ## filter ranges
    
    sp_poly <-
      filter_polygons(
        BL_data = sp_poly,
        presence_codes = c(1, 2, 3),
        seasonal_codes = c(1, 2, 3),
        origin_codes = c(1, 2, 3)
      )
    
    ##### funny thing with some ranges so need to convert back to type MULTIPOLYGON
    
    sp_shape <- spatial_combine_polygons(sp_poly)
    
    ## what sites does this species turn up in the species pool
    
    if (!st_is_valid(sp_shape)) {
      sf_use_s2(FALSE)
    }
    
    
    sp_sites <-
      extract_predicts_sites_LongLat(predicts = PREDICTS, sites =  zero_site)
    
    
    ## spatial points
    
    site_coords <- spatial_coordinates(sp_sites)
    
    
    ## if the site overlaps with the species range code as 1 else 0
    
    mat[zero_site, species] <-
      ifelse(st_intersects(sp_shape, site_coords, sparse = FALSE)[1,], 1, 0)
    
    
    sf_use_s2(TRUE)
  }
  
  return(mat)
  
}


test <- environmental_probability_matrix(species = assembly_species[30])



registerDoParallel(cores = 8)

environmental_probabilities <- foreach(species = assembly_species[1:10],.combine = "cbind",.inorder = FALSE, .packages = c("tidyverse", "maptools", "rgdal", "sp", "raster","rgeos","sf","fasterize")) %dopar% {
  
  environmental_prob <- environmental_probability_matrix(species)
  return(environmental_prob)
  
}


registerDoSEQ()
closeAllConnections()




#write_rds(environmental_probabilities, file = "Outputs/sp_environmental_probabilities.rds")

```


