---
title: "Hypervolume_analyses"
author: "Patrick Alexander Walkden"
date: "29/10/2021"
output:
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
library(rgl)
setupKnitr(autoprint = TRUE)
knitr::knit_hooks$set(webgl = hook_webgl)
knitr::opts_chunk$set(echo = TRUE)
```

## Hypervolume Analyses

Following generating the species pool and performing randomisations it's time to look at how the occupancy of functional trait space as described by the TPD functions is distributed within each land-use and how the structure of this trait space differs across land-use types and compared to null communities. 

The structure of functional trait space characterized by hypervolumes can be described in a number of ways, as well as the typical metrics of Functional richness, divergence and evenness, a measure of "holeyness" can be determined. Holeyness within hypervolumes indicates empty functional space and potentially an unoccupied niche as a result of extinctions or trait combinations that are unfeasible in an environmental context.[REF x 2]

First, I am going to visualize the structure of occupied trait space across land uses within biogeographic realms 



```{r load in packages and data, echo = FALSE}
rm(list = ls())

## loading in tidyverse and the functions I have created to analyise and visualise the differences between TPD hypervolumes
require(tidyverse)#
require(ggpubr) # to aggregate plots
require(lme4)
require(ggResidpanel)
require(multcomp)
source("Functions/TPD_3D_plots.R")

## load in all the data

 PREDICTS_tpds <- readRDS("Outputs/PREDICTS_sites_tpds.rds") # morphometric TPDs of observed sites
 
 PREDICTS_randomisations <- readRDS("Outputs/randomisations_TPD_morpho.rds") ## morphometric TPD of randomisised sites 
 
 PREDICTS_full <- readRDS("Outputs/refined_predicts.rds")
 
 PREDICTS <- PREDICTS_full %>%  ## PREDICTS data 
   dplyr::distinct(SSBS, Predominant_habitat, Use_intensity, Biome, UN_subregion, Realm, SS) %>% ## pull out land_use type, Subregion, realm etc
   dplyr::mutate(Predominant_habitat = ifelse(grepl(Predominant_habitat, pattern = "secondary", ignore.case = TRUE), "Secondary vegetation",
                                              paste(Predominant_habitat))) %>% data.frame() ## merge all secondary sites together
 
 
 species_TPD <- readRDS("Outputs/species_tpds_morpho.rds") ## individual species TPDs 

```

# site distribution

First things first, lets see how the sites that have a TPD calculated for them are distributed across land-uses and biogeographic realms.


```{r sites in lu and realm}
 
### get the land uses and use intensity of all the sites TPDs could be caluclated for 

 TPD_LU <- data.frame(SSBS = names(PREDICTS_tpds)) %>% dplyr::left_join(PREDICTS) %>% dplyr::filter(Predominant_habitat != "Cannot decice",
                                                                                                    Use_intensity != "Cannot decide")
### check a table
 table(TPD_LU$Predominant_habitat, TPD_LU$Realm)
```
I have decided to pool together sites with biogeographic realms as

Here we can see that there is quite an uneven spread of sites across the LU types and Realms so to check whether there are enough sites I am going to iteratively calculate functional diversity metrics for each LU-realm combination and if FD reaches an asymptote it will indicate that there are sufficent sites so that trait spaces can be compared.

```{r LU realm combos, echo = FALSE, cache=TRUE, message=FALSE, results = 'hide'}

### pull land_uses

land_uses <- PREDICTS %>% dplyr::distinct(Predominant_habitat, .keep_all = FALSE) %>% dplyr::filter(Predominant_habitat != "Cannot decide") %>% 
   pull() %>% as.character()

## pull realms 

realms <- as.character(unique(TPD_LU$Realm))
   
### get combinations of land uses and realms

combinations <- expand.grid(land_uses,realms) %>% set_colnames(c("land_use","realm"))

## check list for each combination I am adding each site in turn and calculating the resultant Functional Richness of the overall hypervolume - if the functional richness asymptotes before the sites run out then there are enough samples for the LUs to be compared  

if(any(grepl(list.files("Outputs"), pattern = "check_list"))){
 Check_list <- readRDS(grep(list.files("Outputs", full.names = TRUE), pattern = "check_list", value = TRUE)) 
} else {

  Check_list <- list()
  for(i in 1:nrow(combinations)){
  
    Land_use <- as.character(combinations[i,"land_use"])
    Realm <- as.character(combinations[i,"realm"])
    
    # This function will compute these metric and also produce a ggplot representation
    
    list <-   TPD_site_check(data = PREDICTS_tpds, LU = Land_use , realm = Realm)
    
    Check_list[[i]] <- list
    names(Check_list)[i] <- paste(Land_use, Realm, sep = "/")
  }
  write_rds("Outputs/realm_lu_check_list.rds", x = Check_list)
}
```
Now let's have a look! I have checked all the plot but I am going to exhibit just a couple here 

```{r realm checking}
sites <- c(1,11,31)

for(i in sites){
  
  if(is_empty(Check_list[[i]])){
    next()
  }
    figure <- Check_list[[i]]$ggplots
    figure <- annotate_figure(figure,
                    top = text_grob(paste(names(Check_list)[i]), color = "red", face = "bold", size = 14))

plot(figure)
}


```

So upon examining the plots there are a good number of LU/realm combinations that have sufficient sites to reasonably represent the occupancy of functional trait space.

Above are some examples of the variety of different patterns produced. Plantation forest in the Palearctic clearly is sufficeintly sampled. Pasture in the Afrotropics. although containing only a few sites does exhibit an asymptote and has been included for now but may need to be dropped later, and finally cropland in the Nearctic which is showing Functional richness is still increasing so therefore has not been sufficeintly sampled and therefore dropped. 

So....

In the Afrotropics we can compare Cropland, Pasture, Plantation forest, Primary forest, Primary non-forest and Secondary vegetation.

In Australasia we can compare Pasture, Primary forest, Primary non-forest and Secondary vegetation.

In Indo-Malay we can compare Cropland, Plantation forest, Primary forest, and Secondary vegetation.

In the Nearctic we can compare Cropland, Pasture, Primary forest, Primary non-forest and Secondary vegetation.

In the Neotropics we can compare Cropland, Pasture, Plantation forest, Primary forest, and Secondary vegetation.

In the Palearctic we can compare Cropland, Pasture, Plantation forest, Primary forest, Primary non-forest and Secondary vegetation.


Primary forest is the only land-use classification that is well represented ubiquitously across the realms, but there is also good coverage from secondary vegetation, plantation forest, pasture and, maybe, cropland. 

Urban and primary non-forest classifications are represented well in only three of the realms... maybe a case for combining primary sites together??

However, for now lets have a look at these trait spaces and use Primary forest sites in the Afrotropics as an example.


```{r site occupancy visualisation, webgl = TRUE}

pri_afro <- TPD_LU %>% dplyr::filter(Predominant_habitat == "Primary forest", Realm == "Afrotropic") %>% dplyr::distinct(SSBS) %>% pull()

TPD_3d_plot(data = PREDICTS_tpds, sites = pri_afro, T1lab = "Locomotion", T2lab = "Foraging", T3lab = "Body", method = "prob", title = "TPD_test_plot")

```

In this plot you can see a 3D plot representing the occupancy of trait space in the three dimensions characterised by our axes of the forgaing, locomotory and body niches. 

Scores on the body dimension track the size of the bird. 

High scores on the locomotory axis represent long tarsus' with slight increases in secondary wing lengths, while lower scores indicate longer tails and minor increases in wing length. 

The foraging niche is based on the dimensions of the beak and high scores representing wide, deep beaks and as scores decrease beaks tend towards those that are longer and thinner. 

It's all well and good being able to represent these trait spaces but what do they represent and how do they differ across land use gradients within biogeographic realms.

```{r FD_TPD metrics, fig.width= 10}

## create a list with the land use classifications for each realm

realm_land_uses <- list()
realm_land_uses[["Afrotropic"]] <- c("Primary forest","Primary non-forest", "Secondary vegetation","Plantation forest","Pasture","Cropland")
realm_land_uses[["Australasia"]] <- c("Primary forest","Primary non-forest", "Secondary vegetation", "Pasture")
realm_land_uses[["Indo-Malay"]] <- c("Primary forest","Secondary vegetation","Plantation forest","Cropland")
realm_land_uses[["Nearctic"]] <- c("Primary forest","Primary non-forest", "Pasture","Cropland", "Urban")
realm_land_uses[["Neotropic"]] <- c("Primary forest","Secondary vegetation","Plantation forest","Pasture","Cropland","Urban")
realm_land_uses[["Palearctic"]] <- c("Primary forest","Secondary vegetation", "Plantation forest","Pasture","Cropland","Urban")


##iterate through each realm
plot_data <- c()

for(r in realms){
  
# get the land uses 
  
    land_uses <- realm_land_uses[[r]]
  
  # empty data frame for the plot data   
    
  
  
  ## iterate through the land uses 
  
  for(LU in land_uses){
  
  ## get the sites of that land use type in a particular realm  
    
  lu_sites <- TPD_LU %>% dplyr::filter(Predominant_habitat == LU, Realm == r) %>% dplyr::distinct(SSBS) %>% pull()
  
  ## calcualte FRich, FDiv and FEve metrics making sure to mark those values that relate to individual sites values or combined
  
  metrics <- TPD_FD_metrics(data = PREDICTS_tpds, sites = lu_sites)
  metrics$Realm <- r
  metrics$Land_use <- LU
  metrics$group <- "individual_sites"
  metrics$group[nrow(metrics)] <- "combined_sites"
  metrics$group <- factor(metrics$group)
  plot_data <- rbind(plot_data,metrics)
  }
  
## factor and level plot data in order of human impact
  
  p_data <- plot_data %>% dplyr::filter(Realm == r)
  p_data$Land_use <- factor(p_data$Land_use, levels = land_uses)
  
  # Frichness plot
  
  p_rich <- ggplot(data = p_data, aes(x = group, y = FRich)) +
    geom_boxplot(aes(fill = Land_use))
  
  #Fdivergence plot
  
  p_div <- ggplot(data = p_data, aes(x = group, y = FDiv)) +
    geom_boxplot(aes(fill = Land_use))
  
  # Feveness plot
  
  p_eve <- ggplot(data = p_data, aes(x = group, y = FEve)) +
    geom_boxplot(aes(fill = Land_use))
  
  ## join all 
  
  p <- ggpubr::ggarrange(p_rich,p_div,p_eve, nrow = 1, common.legend = TRUE)
  
  # add title
  
  p <- annotate_figure(p,
                    top = text_grob(paste(r,"Funtional Richness, divergence and eveness plots"), color = "red", face = "bold", size = 14))
  plot(p)
}

```
insert something about some interesting cases here 

## Differences between hypervolumes

Now let's calculate some beta-diversity metrics between the sites and characterise just how land use change is influencing the structure of functional trait space.

```{r site dissimlarity}

## create a list to gather the beta diveristy metrics between each land use tyoe within biogeographic realm

  dissim_list <- list()
  
#  iterate through realms
for(r in realms){
    
  # get the land uses 
  
  land_uses <- realm_land_uses[[r]]
    
  ## get each combination of land uses within the realm
  
  LU_combo <- matrix(gtools::combinations(n = length(land_uses), r = 2, v = land_uses,set = TRUE), ncol = 2) %>% data.frame() %>% set_colnames(c("LU1","LU2"))
  
  ## create an empty array that is going to hold three pairwise matrices 1) beta diversity 2) beta partitioned into nestedness 3) turnover
  
  array_dimnames <- list(c(land_uses),c(land_uses),c("Dissimilarity","Shared","Not_shared"))
  LU_array <- array(rep(NA,(length(land_uses)^2)*3),dim = c(length(land_uses),length(land_uses),3), dimnames = array_dimnames)
  
  ## for each combination
  
  for(i in 1:nrow(LU_combo)){
    
    # get each LU sites 
    
    sites_1 <- TPD_LU %>% dplyr::filter(Realm == r, Predominant_habitat == LU_combo[i,"LU1"]) %>% dplyr::distinct(SSBS) %>% pull()
    sites_2 <- TPD_LU %>% dplyr::filter(Realm == r, Predominant_habitat == LU_combo[i,"LU2"]) %>% dplyr::distinct(SSBS) %>% pull()
    
    ## calculate the dissimilarity
    
    dissimilarity <- Calc_dissim(data = PREDICTS_tpds,sites1 = sites_1, sites2 = sites_2)
    
    ## assign the dissimilarity to the array 
    
    LU_array[LU_combo[i,"LU1"],LU_combo[i,"LU2"],"Dissimilarity"] <- dissimilarity[["dissim"]][["dissimilarity"]]
    LU_array[LU_combo[i,"LU1"],LU_combo[i,"LU2"],"Shared"] <- dissimilarity[["dissim"]][["P_shared"]]
    LU_array[LU_combo[i,"LU1"],LU_combo[i,"LU2"],"Not_shared"] <- dissimilarity[["dissim"]][["P_non_shared"]]
    
    LU_array[LU_combo[i,"LU2"],LU_combo[i,"LU1"],"Dissimilarity"] <- dissimilarity[["dissim"]][["dissimilarity"]]
    LU_array[LU_combo[i,"LU2"],LU_combo[i,"LU1"],"Shared"] <- dissimilarity[["dissim"]][["P_shared"]]
    LU_array[LU_combo[i,"LU2"],LU_combo[i,"LU1"],"Not_shared"] <- dissimilarity[["dissim"]][["P_non_shared"]]
  
    
  }
    ## assign this to the overall list
  dissim_list[[r]][["dissim_array"]] <- LU_array
  
  
  }

## load in a dissimlarity plot with some code I adapted from pairwise plots 

source("Functions/PREDICTS_dissim_plot.R")

for(i in 1:length(dissim_list)){
PREDICTS_dissim_plot(dissim_list[[i]][[1]])
  title(main = paste(names(dissim_list)[i]))
}

```
### What areas of trait space are 


## Hypervolume holes


```{r hypervolume holes}

## create empty data frame to add metrics of interior and exterior holes 

holes_frame <- c()

for(r in realms){
  
  ### get the land uses 
    
  land_uses <- realm_land_uses[[r]]
  
  ## get proportion and volume of interior and exterior holes 
  hole_mat <- matrix(rep(NA,length(land_uses)*4), ncol = 4) %>% data.frame()
  rownames(hole_mat) <- land_uses
  colnames(hole_mat) <- c("total_hole_volume_int","proportion_to_observed_int","total_hole_volume_ext","proportion_to_observed_ext" )
  
  #iterate through land uses 
  
  for(LU in land_uses){
  
  lu_sites <- TPD_LU %>% dplyr::filter(Predominant_habitat == LU, Realm == r) %>% dplyr::distinct(SSBS) %>% pull()
  
  ## calculate hole metrics with a threshold of 0.95 quantile from the randomisations to be considered a hole 
  
  holes <- TPD_holes(data = PREDICTS_tpds, randata = PREDICTS_randomisations, sites = lu_sites, threshold = 0.95)
  
  ### add the internal and external metrics to the data frame
  
  hole_mat[LU,] <- c(unlist(holes$internal[c("total_hole_volume","proportion_holes_volume")]),
                     unlist(holes$external[c("total_hole_volume","proportion_holes_volume")]))
  }
  
  ### add columns for realm and LU
  
  hole_mat$Realm <- r
  hole_mat$Land_use <- land_uses
  hole_mat$Land_use <- factor(hole_mat$Land_use, levels = land_uses)
  rownames(hole_mat) <- 1:nrow(hole_mat)
  
  
  holes_frame <- rbind(holes_frame,hole_mat)  
  
}


holes_frame$Land_use <- factor(holes_frame$Land_use, levels = c("Primary forest", "Primary non-forest", "Secondary vegetation", "Plantation forest", "Pasture", "Cropland", "Urban"))
## for each create a plot

for(r in realms ){
 hole_plot_data <- holes_frame %>% dplyr::filter(Realm == r)
  
  p_rich <- ggplot(data = hole_plot_data, aes(x = Land_use, y = proportion_to_observed_int)) +
    geom_bar(stat = "identity") +
    ggtitle(paste(r))
    
plot(p_rich)
}
 



```

## Where are these holes? What species occupy the empty space?

By looking at what species occupy the functional trait space left vacant in observed communities compared to randomised null communites we can begin to see how the change in the structure of functional trait space --- Could we have basically just done this with species identities?? The whole point is to get beyond this point just considering traits, although this could then be like these could be candidate species for re-introductions as they occupy niche space that is currently not being filled. 

Additionally, we can have a look better at which areas of traits space are favoured or lost across a land use gradient by looking at the differences between the hypervolumes of each last use type and identifying areas that drop in and out of occupancy.

```{r species in the holes, fig.width=10}

## First load in Foraging guild and species pools data 

Forage <- readRDS(file = "../PREDICTS_Taxonomy/PREDICTS_imputed_BL_traits_forage.rds")
species_pools <- readRDS("Outputs/predicts_sites_species_pools.rds")

## if holey species list identifying which species occupy holes left compared to random across realms and LU types load it otherwise...




pool_sp <- function(df,sites, pool){
  
  pool_species <- c()
    for(sit in sites){
      pool_species <- unique(c(pool_species,species_pools[[sit]][["0.9"]]))
    }
  
    for(i in 1:nrow(df)){
        sp <- unlist(strsplit(df[i,"occupying_species"],split = "/"))
        df[i,"occupying_species"] <- paste(sp[which(sp %in% pool_species)], collapse = "/")
    }
  
  return(df)
  
}

split_sp_func <- function(df){
  species <- c()
  for(i in 1:nrow(df)){
  species <- unique(c(species,unlist(strsplit(df[i,"occupying_species"], split = "/"))))
  }
  return(species)
}


################################################
#################################################

if(any(grepl(x = list.files("Outputs"), pattern = "holey_species"))){
  holey_species <- readRDS(grep(list.files("Outputs", full.names = TRUE), value = TRUE, pattern = "holey_species"))
} else {
  
# create empty list   
  
holey_species <- list()

#iterate through realms

for(r in realms){
  
  ## get the land uses 
  
  land_uses <- realm_land_uses[[r]]
  
  # iterate through land uses 
  
  for(LU in land_uses){
  
  ## get sites 
    
  lu_sites <- TPD_LU %>% dplyr::filter(Predominant_habitat == LU, Realm == r) %>% dplyr::distinct(SSBS) %>% pull()
  
  ## identify where holes are compared to random
  
  holes <- TPD_holes(data = PREDICTS_tpds, randata = PREDICTS_randomisations, sites = lu_sites[1], threshold = 0.95)
  
  ## determine which species fit in these holes based on their functional traits 
  
  internal_species <- species_fit(holes[["internal"]][["internal_hole_cells"]])
  
  ## This produces a data frame
  
  
  
  ##### now this is all the species that are in the entirety of the assembly species pool so now I'm going to filter just for those species that are in the species pools of all the sites combined.
 
  internal_species <- pool_sp(internal_species)
  
  
   holey_species[paste(r,LU,sep = "_")] <- internal_species
  }
}

write_rds(holey_species, file = "Outputs/holey_species.rds")

}









hole_plot_sp <- c()

for( r in realms){

  land_uses <- realm_land_uses[[r]]
  
for(LU in land_uses){

  data <- holey_species[[paste(r,LU,sep = "_")]]
  
r_lu_hole_sp <- split_sp_func(data)



hole_sp_for <- data.frame(Birdlife_Name = r_lu_hole_sp, Land_use = LU, Realm = r) %>% dplyr::left_join(Forage[,c("Birdlife_Name", "Trophic_Level", "Trophic_Niche", "Foraging_Niche")], by = "Birdlife_Name")

hole_sp_for$Trophic_Niche <- factor(hole_sp_for$Trophic_Niche)


hole_plot_sp <- rbind(hole_plot_sp,hole_sp_for)

}
}

hole_plot_sp$Land_use <- factor(hole_plot_sp$Land_use,
                                levels = c("Primary forest", "Primary non-forest", "Secondary vegetation", "Plantation forest",
                                           "Pasture", "Cropland", "Urban"))
hole_plot_sp$Trophic_Niche <- factor(hole_plot_sp$Trophic_Niche, levels = c("In", "Fr","Gr", "Ne", "Hb.T", "Hb.A", "Vt", "Aq.p","Om" ))

hole_plot_sp <- hole_plot_sp %>% dplyr::mutate(Foraging_Niche = ifelse(Foraging_Niche == "For.Gen", "For.Gen","Spec"))




for(r in realms){

  ### Or could weight it by the size of the hole?? But I've gone for size of the observed communitity and this point but hole size may be better 
  
  weights <- holes_frame%>% dplyr::filter(Realm == r)
  
  data <- hole_plot_sp %>% dplyr::filter(Realm == r) %>% group_by(Trophic_Niche, Foraging_Niche, Land_use) %>% dplyr::summarise(count = n(), .groups = "drop") %>% dplyr::left_join(weights[,c("Land_use", "total_hole_volume_int")], by = "Land_use") %>% dplyr::mutate(relative_sp_occupancy = count/total_hole_volume_int)
    

hole_sp_plot <- ggplot(data = data, aes( x = Land_use, y = relative_sp_occupancy, fill = Foraging_Niche)) +
  geom_bar(stat = "identity") +
  facet_grid(. ~Trophic_Niche) +
  ylim(0,550) +
  ggtitle(paste(r,sep = "_")) +
  theme(axis.text.x = element_text(angle = 90))

plot(hole_sp_plot)
}
###################################################
###################################################
 ## Let's now look at individual site holeyness
```


```{r}
require(future)
require(future.apply)
require(car)
require(lmerTest)
require(merTools)


if(any(grepl(list.files("Outputs"), pattern = "site_holes.rds"))){
  site_hole <- readRDS(grep(list.files("Outputs",full.names = TRUE),pattern = "site_holes.rds", value = TRUE))
} else{

plan(multicore(workers = 8))

all_sites <- lapply(TPD_LU$SSBS, paste)
names(all_sites) <- TPD_LU$SSBS

site_hole <- future_lapply(all_sites, TPD_holes, data = PREDICTS_tpds, randata = PREDICTS_randomisations, threshold = 0.95)


closeAllConnections()


site_hole <- readRDS("Outputs/site_holes.rds")
}


site_hole$Predominant_habitat <- relevel(factor(site_hole$Predominant_habitat), ref = "Primary forest")
site_hole$Realm <- relevel(factor(site_hole$Realm), ref = "Neotropic")





site_hole <- site_hole %>% dplyr::left_join(PREDICTS[,c("SSBS", "SS")], by = "SSBS") %>% distinct(SSBS, .keep_all = TRUE)

FD_mets <- TPD_FD_metrics(data = PREDICTS_tpds, sites = site_hole$SSBS)

site_hole$F_Rich <- FD_mets$FRich[-nrow(FD_mets)]
site_hole$logF_Rich <- log(site_hole$F_Rich)

site_hole$F_Div <- FD_mets$FDiv[-nrow(FD_mets)]



plot(site_hole$internal_hole_prop ~ site_hole$F_Rich)



site_mod <- lmer(internal_hole_prop ~ Predominant_habitat + logF_Rich + Realm + Predominant_habitat:Realm + (1|SS), data = site_hole)



summary(site_mod)
Anova(site_mod, type = "III")

ggResidpanel::resid_panel(site_mod)




realms <- c(rep("Afrotropic",7),
rep("Australasia",7),
rep("Nearctic",7),
rep("Neotropic",7),
rep("Indo-Malay",7),
rep("Palearctic",7))

LUs <- rep(c("Primary forest", "Primary non-forest", "Secondary vegetation", "Plantation forest", "Pasture", "Cropland", "Urban"),6)



lala <- data.frame(Realm = realms, Predominant_habitat = LUs) 
lala$logF_Rich <- NA


for(i in 1:nrow(lala)){
  ph <- lala[i,"Predominant_habitat"]
  r <- lala[i,"Realm"]
lala[i,"logF_Rich"] <- log(mean(site_hole[which(site_hole$Predominant_habitat == ph & site_hole$Realm == r),"F_Rich"]))
}

drop_rows <- c(30,33, 17)

lala <- lala[-drop_rows,]


pred_fun <- function(x){
  as.numeric(predict(x, newdata = lala, re.form = NA))
}

lala$predicted <- pred_fun(site_mod)
lala$upper <- NA
lala$lower <- NA


booted_mod <- bootMer(site_mod, FUN = function(x) pred_fun(x), nsim = 200)

estimates <- booted_mod$t0

bootstraps <- booted_mod$t

for(i in 1:ncol(bootstraps)){
  lala[i,"upper"] <- as.numeric(quantile(bootstraps[,i], 0.95))
  lala[i,"lower"] <- as.numeric(quantile(bootstraps[,i], 0.05))

  }

###############################
###############################
# Now the plot

lala$Predominant_habitat <- factor(lala$Predominant_habitat, levels = c("Primary forest", "Primary non-forest", "Secondary vegetation", "Plantation forest", "Pasture", "Cropland", "Urban"))

levels(lala$Predominant_habitat) <- c("PriFor","PriNFor","SecVeg","PlnFor","Pas","Crp","Urb")


for(r in unique(realms)){

  p_d <- lala %>% dplyr::filter(Realm == r)
  
  pri_intercept <- p_d %>% dplyr::filter(Predominant_habitat == "PriFor") %>% pull(predicted)
  
plot <- ggplot(data = p_d, aes(x = Predominant_habitat, y = predicted, colour = Predominant_habitat)) +
  geom_errorbar(aes(ymin=ifelse(lower< 0, 0, lower) , ymax= upper), colour="black", width=.1, position=pd, linetype = 1) +
  geom_point(position=pd,size=6)+
  xlab("Land use") +
  ylab("Holeyness") +
  scale_colour_hue(name="Use intensity",    # Legend label, use darker colors
                   breaks=c("Minimal", "Light","Intense","All"),
                   labels=c("Minimal", "Light","Intense","All"),
                   l=40) +                    # Use darker colors, lightness=40+
  expand_limits(y=0) +
  ggtitle(paste(r))+
  ylim(0,4)+
  theme_classic() +
  geom_hline(yintercept= pri_intercept, linetype='dotted', col = 'red')+
  theme(legend.justification=c(1,0),
        legend.position=c(1,0.65),
        text = element_text(size = 20))+
  theme(axis.text.x = element_text(angle = 90))

plot(plot)
}
```


```{r species difference}



diff_species <- function(realm){
  
  dif_sp <- list()
  
 land_uses <- realm_land_uses[[realm]]
    
  ## get each combination of land uses within the realm
  
  LU_combo <- matrix(gtools::combinations(n = length(land_uses), r = 2, v = land_uses,set = TRUE), ncol = 2) %>% data.frame() %>% set_colnames(c("LU1","LU2"))

  
  for(i in 1:nrow(LU_combo)){
    
    
    sites_1 <- TPD_LU %>% dplyr::filter(Realm == r, Predominant_habitat == LU_combo[i,"LU1"]) %>% dplyr::distinct(SSBS) %>% pull()
    sites_2 <- TPD_LU %>% dplyr::filter(Realm == r, Predominant_habitat == LU_combo[i,"LU2"]) %>% dplyr::distinct(SSBS) %>% pull()
    
    
    loss_gain <- TPD_species_occupancy(data = PREDICTS_tpds, sites1 = sites_1, sites2 = sites_2)
    
    gain_sp <- split_sp_func(pool_sp(loss_gain[["gain_species"]], sites = c(sites_1,sites_2), pool = "0.9"))
    lost_sp <- split_sp_func(pool_sp(loss_gain[["lost_species"]], sites = c(sites_1,sites_2), pool = "0.9"))
  
   
  dif_sp[[paste(realm,LU_combo[i,"LU1"],LU_combo[i,"LU2"], sep = "_")]]$gain <- gain_sp  
  dif_sp[[paste(realm,LU_combo[i,"LU1"],LU_combo[i,"LU2"], sep = "_")]]$lost <- lost_sp

  }
  
  return(dif_sp)
  
}


if(any(grepl(list.files("Outputs"), pattern = "pairwise_sp_difs.rds"))){
  pairwise_sp_difs <- readRDS(grep(list.files("Outputs",full.names = TRUE),pattern = "pairwise_sp_difs.rds", value = TRUE))
} else{
plan(multicore(workers = 8))

realm_list <- lapply(realms, paste)

pairwise_sp_difs <- future_lapply(realm_list, diff_species)

closeAllConnections()

write_rds("Outputs/pairwise_sp_difs.rds", pairwise_sp_difs)
}




```

